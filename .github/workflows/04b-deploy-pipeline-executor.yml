name: "04b Â· Deploy Pipeline Executor"

on:
  push:
    branches: [main]
    paths: ['backend/**']
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: choice
        options: [dev, staging, prod]

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    name: Deploy Pipeline Executor (${{ inputs.environment || 'dev' }})
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || 'dev' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Dependencies
        working-directory: backend
        run: npm install

      - name: Build
        working-directory: backend
        run: npm run build

      - name: Verify Pipeline Executor Handler
        working-directory: backend
        run: |
          set -euo pipefail
          if [ ! -f dist/pipeline-executor.handler.js ]; then
            echo "::error::dist/pipeline-executor.handler.js not found â€” nest build may not have compiled it"
            exit 1
          fi
          echo "âœ… pipeline-executor.handler.js present in dist/"

      - name: Package Lambda Artifact
        working-directory: backend
        run: |
          set -euo pipefail
          mkdir -p deployment
          cp -r dist deployment/
          cp package.json package-lock.json deployment/
          cd deployment
          npm ci --omit=dev
          zip -r ../lambda-package.zip .

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.PLATFORM_ADMIN_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}

      - name: Pre-flight - Verify Lambda Exists
        env:
          FUNCTION_NAME: ${{ vars.PROJECT_NAME || 'license-portal' }}-${{ inputs.environment || 'dev' }}-pipeline-executor
        run: |
          set -euo pipefail
          echo "ðŸ” Checking if Lambda function '${FUNCTION_NAME}' exists..."
          if ! aws lambda get-function --function-name "${FUNCTION_NAME}" > /dev/null 2>&1; then
            echo "::error::Lambda function '${FUNCTION_NAME}' not found. Run the Terraform Apply workflow (02) first to provision infrastructure before deploying code."
            exit 1
          fi
          echo "âœ… Lambda function '${FUNCTION_NAME}' exists"

      - name: Deploy Pipeline Executor Lambda
        env:
          FUNCTION_NAME: ${{ vars.PROJECT_NAME || 'license-portal' }}-${{ inputs.environment || 'dev' }}-pipeline-executor
        run: |
          set -euo pipefail
          
          echo "Deploying pipeline executor: ${FUNCTION_NAME}"
          
          # Update function code on $LATEST first (do NOT publish yet)
          aws lambda update-function-code \
            --function-name "${FUNCTION_NAME}" \
            --zip-file fileb://backend/lambda-package.zip

          # Wait for code update to stabilize before changing configuration
          aws lambda wait function-updated-v2 \
            --function-name "${FUNCTION_NAME}"

          # Ensure handler points to compiled entry point on $LATEST
          aws lambda update-function-configuration \
            --function-name "${FUNCTION_NAME}" \
            --handler "dist/pipeline-executor.handler.handler" \
            --runtime "nodejs20.x"

          # Wait for configuration update to complete
          aws lambda wait function-updated-v2 \
            --function-name "${FUNCTION_NAME}"

          # Publish a NEW version after both code + config are correct
          LATEST_VERSION=$(aws lambda publish-version \
            --function-name "${FUNCTION_NAME}" \
            --query "Version" \
            --output text)

          # Update live alias for zero-downtime
          aws lambda update-alias \
            --function-name "${FUNCTION_NAME}" \
            --name live \
            --function-version "${LATEST_VERSION}"

          echo "âœ… Pipeline executor deployed: version ${LATEST_VERSION}"

      - name: Verify Lambda Configuration
        env:
          FUNCTION_NAME: ${{ vars.PROJECT_NAME || 'license-portal' }}-${{ inputs.environment || 'dev' }}-pipeline-executor
        run: |
          set -euo pipefail
          echo "ðŸ” Verifying Lambda configuration..."
          CONFIG=$(aws lambda get-function-configuration --function-name "${FUNCTION_NAME}" --qualifier live --query '{Handler: Handler, Runtime: Runtime, MemorySize: MemorySize, Timeout: Timeout, CodeSize: CodeSize, LastModified: LastModified, Version: Version}' --output json)
          echo "${CONFIG}" | jq .
          
          HANDLER=$(echo "${CONFIG}" | jq -r '.Handler')
          VERSION=$(echo "${CONFIG}" | jq -r '.Version')
          if [ "${HANDLER}" != "dist/pipeline-executor.handler.handler" ]; then
            echo "::error::Handler mismatch on alias 'live': expected 'dist/pipeline-executor.handler.handler', got '${HANDLER}' (version ${VERSION})"
            exit 1
          fi
          echo "âœ… Alias 'live' verified at version ${VERSION} with handler: ${HANDLER}"

      - name: Smoke Test - Invoke with minimal event
        env:
          FUNCTION_NAME: ${{ vars.PROJECT_NAME || 'license-portal' }}-${{ inputs.environment || 'dev' }}-pipeline-executor
        run: |
          set -euo pipefail
          echo "ðŸ§ª Invoking pipeline-executor with a minimal bad-payload to verify bootstrap..."

          # Send an intentionally incomplete payload â€” the handler should return 400
          # (missing required fields) rather than a Runtime.ImportModuleError.
          RESPONSE=$(aws lambda invoke \
            --function-name "${FUNCTION_NAME}" \
            --qualifier live \
            --payload "$(printf '{"smokeTest":true}' | base64)" \
            --cli-binary-format raw-in-base64-out \
            --log-type Tail \
            --query '{StatusCode: StatusCode, FunctionError: FunctionError, LogResult: LogResult}' \
            --output json \
            /tmp/smoke-response.json)

          STATUS_CODE=$(echo "${RESPONSE}" | jq -r '.StatusCode')
          FUNCTION_ERROR=$(echo "${RESPONSE}" | jq -r '.FunctionError // empty')
          BODY=$(cat /tmp/smoke-response.json)

          echo "Status code: ${STATUS_CODE}"
          echo "Function error: ${FUNCTION_ERROR:-none}"
          echo "Response body: ${BODY}"

          # Decode and print last 4KB of logs
          LOG_TAIL=$(echo "${RESPONSE}" | jq -r '.LogResult // empty')
          if [ -n "${LOG_TAIL}" ]; then
            echo "--- Lambda logs (tail) ---"
            echo "${LOG_TAIL}" | base64 -d || true
            echo "--- end logs ---"
          fi

          # A 400 with "Missing required fields" means the handler loaded fine
          HTTP_CODE=$(echo "${BODY}" | jq -r '.statusCode // empty')
          if [ "${HTTP_CODE}" = "400" ]; then
            echo "âœ… Smoke test passed â€” handler bootstrapped and returned expected 400 for bad payload"
          elif [ -n "${FUNCTION_ERROR}" ]; then
            echo "::error::Smoke test FAILED â€” Lambda returned FunctionError: ${FUNCTION_ERROR}. Check logs above."
            exit 1
          else
            echo "::warning::Smoke test returned unexpected status ${HTTP_CODE} â€” review logs above"
          fi

      - name: Deployment Summary
        if: always()
        env:
          FUNCTION_NAME: ${{ vars.PROJECT_NAME || 'license-portal' }}-${{ inputs.environment || 'dev' }}-pipeline-executor
          ENVIRONMENT: ${{ inputs.environment || 'dev' }}
        run: |
          set -euo pipefail
          
          CONFIG=$(aws lambda get-function-configuration \
            --function-name "${FUNCTION_NAME}" \
            --qualifier live \
            --query '{Handler: Handler, Runtime: Runtime, Version: Version, MemorySize: MemorySize, Timeout: Timeout, CodeSize: CodeSize, LastModified: LastModified}' \
            --output json 2>/dev/null || echo '{}')

          HANDLER=$(echo "${CONFIG}" | jq -r '.Handler // "unknown"')
          VERSION=$(echo "${CONFIG}" | jq -r '.Version // "unknown"')
          RUNTIME=$(echo "${CONFIG}" | jq -r '.Runtime // "unknown"')
          MEMORY=$(echo "${CONFIG}" | jq -r '.MemorySize // "unknown"')
          TIMEOUT=$(echo "${CONFIG}" | jq -r '.Timeout // "unknown"')
          CODE_SIZE=$(echo "${CONFIG}" | jq -r '.CodeSize // "unknown"')
          LAST_MODIFIED=$(echo "${CONFIG}" | jq -r '.LastModified // "unknown"')

          echo "### ðŸš€ Pipeline Executor Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Environment** | \`${ENVIRONMENT}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Function** | \`${FUNCTION_NAME}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Alias** | \`live\` â†’ version \`${VERSION}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Handler** | \`${HANDLER}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Runtime** | \`${RUNTIME}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Memory** | ${MEMORY} MB |" >> $GITHUB_STEP_SUMMARY
          echo "| **Timeout** | ${TIMEOUT}s |" >> $GITHUB_STEP_SUMMARY
          echo "| **Code Size** | ${CODE_SIZE} bytes |" >> $GITHUB_STEP_SUMMARY
          echo "| **Last Modified** | ${LAST_MODIFIED} |" >> $GITHUB_STEP_SUMMARY
