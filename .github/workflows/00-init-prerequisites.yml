# =============================================================================
# 00 â€” One-Time Prerequisites: OIDC, IAM Roles, TF State Backend
# =============================================================================
# RUN THIS ONCE before any other workflow.
#
# What it does:
#   1. Creates OIDC Identity Provider in Platform Admin Account (Account 2)
#   2. Creates IAM Role for GitHub Actions in Platform Admin Account (OIDC-based)
#   3. Creates IAM Role for GitHub Actions in Customer Account (Account 3) trusted by Account 2
#   4. Creates S3 bucket + DynamoDB table for Terraform state
#   5. Outputs the role ARNs â†’ you set them as environment secrets
#
# After this workflow succeeds, you NEVER use static AWS keys again.
# All subsequent workflows use OIDC role assumption.
#
# Prerequisites (the ONLY 4 secrets you need to set manually):
#   - AWS_ACCESS_KEY_ID_PLATFORM_ADMIN     (Account 2 admin key)
#   - AWS_SECRET_ACCESS_KEY_PLATFORM_ADMIN (Account 2 admin secret)
#   - AWS_ACCESS_KEY_ID_CUSTOMER           (Account 3 admin key)
#   - AWS_SECRET_ACCESS_KEY_CUSTOMER       (Account 3 admin secret)
#
# After this runs, set environment secrets from the outputs, then delete
# the 4 static key secrets from GitHub (they're no longer needed).
# =============================================================================

name: "00 Â· Init Prerequisites"

on:
  workflow_dispatch:
    inputs:
      aws_region:
        description: 'AWS Region'
        required: true
        default: 'us-east-1'
        type: string
      project_name:
        description: 'Project name (used for resource naming)'
        required: true
        default: 'license-portal'
        type: string
      platform_admin_account_id:
        description: 'AWS Account ID for Platform Admin Account (Account 2)'
        required: true
        type: string
      customer_account_id:
        description: 'AWS Account ID for Customer Account (Account 3)'
        required: true
        type: string
      confirmation:
        description: 'Type INIT to confirm'
        required: true
        type: string
      auto_set_secrets:
        description: 'Automatically set GitHub environment secrets (requires GH_PAT secret with repo scope)'
        required: false
        default: true
        type: boolean
      delete_static_keys:
        description: 'Delete static AWS access keys from GitHub secrets after OIDC setup'
        required: false
        default: false
        type: boolean

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ${{ inputs.aws_region }}
  PROJECT: ${{ inputs.project_name }}

jobs:
  # ===========================================================================
  validate:
    name: "ðŸ”’ Validate"
    runs-on: ubuntu-latest
    outputs:
      confirmed: ${{ steps.check.outputs.confirmed }}
      github_org: ${{ steps.check.outputs.github_org }}
      github_repo: ${{ steps.check.outputs.github_repo }}
    steps:
      - name: Confirm intent
        id: check
        run: |
          if [ "${{ inputs.confirmation }}" != "INIT" ]; then
            echo "::error::Type INIT to confirm. Got: '${{ inputs.confirmation }}'"
            exit 1
          fi
          echo "confirmed=true" >> $GITHUB_OUTPUT
          echo "github_org=${{ github.repository_owner }}" >> $GITHUB_OUTPUT
          echo "github_repo=${{ github.repository }}" >> $GITHUB_OUTPUT

          echo "## ðŸš€ Prerequisites Init" >> $GITHUB_STEP_SUMMARY
          echo "| Setting | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Project | \`${{ inputs.project_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Region | \`${{ inputs.aws_region }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Platform Admin Account | \`${{ inputs.platform_admin_account_id }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Customer Account | \`${{ inputs.customer_account_id }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Repo | \`${{ github.repository }}\` |" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # STEP 1: Setup Platform Admin Account (Account 2)
  # ===========================================================================
  setup-platform-admin:
    name: "ðŸ—ï¸ Setup Platform Admin Account (Account 2)"
    runs-on: ubuntu-latest
    needs: validate
    if: needs.validate.outputs.confirmed == 'true'

    outputs:
      platform_admin_role_arn: ${{ steps.create-role.outputs.role_arn }}
      tf_state_bucket: ${{ steps.create-state.outputs.bucket_name }}
      tf_lock_table: ${{ steps.create-state.outputs.table_name }}
      oidc_provider_arn: ${{ steps.create-oidc.outputs.provider_arn }}

    steps:
      - name: Configure AWS (Platform Admin Account - static keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PLATFORM_ADMIN }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PLATFORM_ADMIN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Validate identity
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          if [ "$ACCOUNT_ID" != "${{ inputs.platform_admin_account_id }}" ]; then
            echo "::error::Expected Account ${{ inputs.platform_admin_account_id }} but got $ACCOUNT_ID"
            exit 1
          fi
          echo "âœ… Authenticated to Platform Admin Account: $ACCOUNT_ID"

      # â”€â”€ OIDC Identity Provider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Create OIDC Identity Provider
        id: create-oidc
        run: |
          set -euo pipefail
          OIDC_URL="https://token.actions.githubusercontent.com"

          # Check if already exists
          EXISTING=$(aws iam list-open-id-connect-providers \
            --query "OpenIDConnectProviderList[?ends_with(Arn, 'token.actions.githubusercontent.com')].Arn" \
            --output text 2>/dev/null || echo "")

          if [ -n "$EXISTING" ] && [ "$EXISTING" != "None" ]; then
            echo "âœ… OIDC provider already exists: $EXISTING"
            echo "provider_arn=$EXISTING" >> $GITHUB_OUTPUT
          else
            # Get GitHub's OIDC thumbprint
            THUMBPRINT=$(openssl s_client -servername token.actions.githubusercontent.com \
              -showcerts -connect token.actions.githubusercontent.com:443 < /dev/null 2>/dev/null \
              | openssl x509 -fingerprint -noout 2>/dev/null \
              | sed 's/://g' | cut -d= -f2 | tr '[:upper:]' '[:lower:]' || echo "6938fd4d98bab03faadb97b34396831e3780aea1")

            PROVIDER_ARN=$(aws iam create-open-id-connect-provider \
              --url "$OIDC_URL" \
              --client-id-list sts.amazonaws.com \
              --thumbprint-list "$THUMBPRINT" \
              --query 'OpenIDConnectProviderArn' \
              --output text)

            echo "âœ… OIDC provider created: $PROVIDER_ARN"
            echo "provider_arn=$PROVIDER_ARN" >> $GITHUB_OUTPUT
          fi

      # â”€â”€ Terraform State Backend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Create Terraform state backend
        id: create-state
        run: |
          set -euo pipefail
          BUCKET="${{ env.PROJECT }}-terraform-state"
          TABLE="${{ env.PROJECT }}-terraform-locks"

          # S3 Bucket
          if aws s3api head-bucket --bucket "$BUCKET" 2>/dev/null; then
            echo "âœ… S3 bucket already exists: $BUCKET"
          else
            if [ "${{ env.AWS_REGION }}" == "us-east-1" ]; then
              aws s3api create-bucket --bucket "$BUCKET"
            else
              aws s3api create-bucket --bucket "$BUCKET" \
                --create-bucket-configuration LocationConstraint="${{ env.AWS_REGION }}"
            fi

            aws s3api put-bucket-versioning \
              --bucket "$BUCKET" \
              --versioning-configuration Status=Enabled

            aws s3api put-bucket-encryption \
              --bucket "$BUCKET" \
              --server-side-encryption-configuration '{
                "Rules": [{"ApplyServerSideEncryptionByDefault": {"SSEAlgorithm": "AES256"}}]
              }'

            aws s3api put-public-access-block \
              --bucket "$BUCKET" \
              --public-access-block-configuration \
                BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true

            echo "âœ… S3 bucket created: $BUCKET"
          fi

          # DynamoDB Lock Table
          if aws dynamodb describe-table --table-name "$TABLE" 2>/dev/null; then
            echo "âœ… DynamoDB table already exists: $TABLE"
          else
            aws dynamodb create-table \
              --table-name "$TABLE" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --tags Key=Project,Value="${{ env.PROJECT }}" Key=ManagedBy,Value=github-actions

            aws dynamodb wait table-exists --table-name "$TABLE"
            echo "âœ… DynamoDB lock table created: $TABLE"
          fi

          echo "bucket_name=$BUCKET" >> $GITHUB_OUTPUT
          echo "table_name=$TABLE"   >> $GITHUB_OUTPUT

      # â”€â”€ IAM Role for GitHub Actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Create Platform Admin IAM Role
        id: create-role
        env:
          GITHUB_REPO: ${{ needs.validate.outputs.github_repo }}
          OIDC_ARN: ${{ steps.create-oidc.outputs.provider_arn }}
          ACCOUNT_ID: ${{ inputs.platform_admin_account_id }}
        run: |
          set -euo pipefail
          ROLE_NAME="${{ env.PROJECT }}-gh-platform-admin"

          # Check if role already exists
          EXISTING_ARN=$(aws iam get-role --role-name "$ROLE_NAME" \
            --query 'Role.Arn' --output text 2>/dev/null || echo "")

          if [ -n "$EXISTING_ARN" ] && [ "$EXISTING_ARN" != "None" ]; then
            echo "âœ… Role already exists: $EXISTING_ARN â€” updating trust policy & inline policy"
            ROLE_ARN="$EXISTING_ARN"

            # Update trust policy on existing role
            printf '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Federated":"%s"},"Action":["sts:AssumeRoleWithWebIdentity","sts:TagSession"],"Condition":{"StringEquals":{"token.actions.githubusercontent.com:aud":"sts.amazonaws.com"},"StringLike":{"token.actions.githubusercontent.com:sub":"repo:%s:*"}}}]}' \
              "${OIDC_ARN}" "${GITHUB_REPO}" > /tmp/trust-policy.json
            aws iam update-assume-role-policy \
              --role-name "$ROLE_NAME" \
              --policy-document file:///tmp/trust-policy.json
            echo "âœ… Trust policy updated"
          else
            # Create trust policy (printf avoids heredoc YAML issues)
            printf '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Federated":"%s"},"Action":["sts:AssumeRoleWithWebIdentity","sts:TagSession"],"Condition":{"StringEquals":{"token.actions.githubusercontent.com:aud":"sts.amazonaws.com"},"StringLike":{"token.actions.githubusercontent.com:sub":"repo:%s:*"}}}]}' \
              "${OIDC_ARN}" "${GITHUB_REPO}" > /tmp/trust-policy.json

            # Create role
            ROLE_ARN=$(aws iam create-role \
              --role-name "$ROLE_NAME" \
              --assume-role-policy-document file:///tmp/trust-policy.json \
              --description "GitHub Actions OIDC role for ${{ env.PROJECT }} platform admin" \
              --tags Key=Project,Value="${{ env.PROJECT }}" Key=ManagedBy,Value=github-actions \
              --query 'Role.Arn' --output text)
          fi

          # Create/update inline policy with required permissions
          printf '%s\n' '{' \
            '"Version": "2012-10-17",' \
            '"Statement": [' \
            '  {' \
            '    "Sid": "CognitoFull",' \
            '    "Effect": "Allow",' \
            '    "Action": "cognito-idp:*",' \
            '    "Resource": "*"' \
            '  },' \
            '  {' \
            '    "Sid": "LambdaFull",' \
            '    "Effect": "Allow",' \
            '    "Action": "lambda:*",' \
            '    "Resource": "*"' \
            '  },' \
            '  {' \
            '    "Sid": "APIGateway",' \
            '    "Effect": "Allow",' \
            '    "Action": "apigateway:*",' \
            '    "Resource": "*"' \
            '  },' \
            '  {' \
            '    "Sid": "S3Full",' \
            '    "Effect": "Allow",' \
            '    "Action": "s3:*",' \
            '    "Resource": "*"' \
            '  },' \
            '  {' \
            '    "Sid": "DynamoDB",' \
            '    "Effect": "Allow",' \
            '    "Action": "dynamodb:*",' \
            '    "Resource": "*"' \
            '  },' \
            '  {' \
            '    "Sid": "SSM",' \
            '    "Effect": "Allow",' \
            '    "Action": "ssm:*",' \
            '    "Resource": "*"' \
            '  },' \
            '  {' \
            '    "Sid": "CloudFormation",' \
            '    "Effect": "Allow",' \
            '    "Action": "cloudformation:*",' \
            '    "Resource": "*"' \
            '  },' \
            '  {' \
            '    "Sid": "CloudWatch",' \
            '    "Effect": "Allow",' \
            '    "Action": ["cloudwatch:*", "logs:*", "sns:*"],' \
            '    "Resource": "*"' \
            '  },' \
            '  {' \
            '    "Sid": "CloudFront",' \
            '    "Effect": "Allow",' \
            '    "Action": "cloudfront:*",' \
            '    "Resource": "*"' \
            '  },' \
            '  {' \
            '    "Sid": "StepFunctions",' \
            '    "Effect": "Allow",' \
            '    "Action": "states:*",' \
            '    "Resource": "*"' \
            '  },' \
            '  {' \
            '    "Sid": "VPC",' \
            '    "Effect": "Allow",' \
            '    "Action": [' \
            '      "ec2:CreateVpc", "ec2:DeleteVpc", "ec2:DescribeVpcs",' \
            '      "ec2:ModifyVpcAttribute", "ec2:CreateSubnet", "ec2:DeleteSubnet",' \
            '      "ec2:DescribeSubnets", "ec2:CreateRouteTable", "ec2:DeleteRouteTable",' \
            '      "ec2:DescribeRouteTables", "ec2:CreateRoute", "ec2:DeleteRoute",' \
            '      "ec2:AssociateRouteTable", "ec2:DisassociateRouteTable",' \
            '      "ec2:CreateInternetGateway", "ec2:DeleteInternetGateway",' \
            '      "ec2:AttachInternetGateway", "ec2:DetachInternetGateway",' \
            '      "ec2:DescribeInternetGateways",' \
            '      "ec2:AllocateAddress", "ec2:ReleaseAddress", "ec2:DescribeAddresses",' \
            '      "ec2:CreateNatGateway", "ec2:DeleteNatGateway", "ec2:DescribeNatGateways",' \
            '      "ec2:CreateVpcEndpoint", "ec2:DeleteVpcEndpoints",' \
            '      "ec2:DescribeVpcEndpoints", "ec2:ModifyVpcEndpoint",' \
            '      "ec2:CreateSecurityGroup", "ec2:DeleteSecurityGroup",' \
            '      "ec2:DescribeSecurityGroups", "ec2:AuthorizeSecurityGroupIngress",' \
            '      "ec2:AuthorizeSecurityGroupEgress", "ec2:RevokeSecurityGroupIngress",' \
            '      "ec2:RevokeSecurityGroupEgress",' \
            '      "ec2:DescribeAvailabilityZones", "ec2:DescribeNetworkInterfaces",' \
            '      "ec2:CreateTags", "ec2:DeleteTags", "ec2:DescribeTags",' \
            '      "ec2:DescribePrefixLists",' \
            '      "ec2:DescribeVpcAttribute", "ec2:DescribeAddressesAttribute",' \
            '      "ec2:ModifySubnetAttribute", "ec2:DescribeVpcEndpointServices"' \
            '    ],' \
            '    "Resource": "*"' \
            '  },' \
            '  {' \
            '    "Sid": "IAMFull",' \
            '    "Effect": "Allow",' \
            '    "Action": [' \
            '      "iam:PassRole", "iam:GetRole", "iam:CreateRole", "iam:DeleteRole",' \
            '      "iam:AttachRolePolicy", "iam:DetachRolePolicy",' \
            '      "iam:PutRolePolicy", "iam:DeleteRolePolicy",' \
            '      "iam:GetRolePolicy", "iam:ListRolePolicies",' \
            '      "iam:ListAttachedRolePolicies", "iam:TagRole",' \
            '      "iam:CreateServiceLinkedRole", "iam:ListInstanceProfilesForRole"' \
            '    ],' \
            '    "Resource": "*"' \
            '  },' \
            '  {' \
            '    "Sid": "AssumeCustomerAccount",' \
            '    "Effect": "Allow",' \
            '    "Action": ["sts:AssumeRole", "sts:TagSession"],' \
            "    \"Resource\": \"arn:aws:iam::${{ inputs.customer_account_id }}:role/${{ env.PROJECT }}-*\"" \
            '  },' \
            '  {' \
            '    "Sid": "STSGetCaller",' \
            '    "Effect": "Allow",' \
            '    "Action": "sts:GetCallerIdentity",' \
            '    "Resource": "*"' \
            '  }' \
            ']' \
            '}' > /tmp/platform-admin-policy.json

          aws iam put-role-policy \
            --role-name "$ROLE_NAME" \
            --policy-name "${ROLE_NAME}-policy" \
            --policy-document file:///tmp/platform-admin-policy.json

          echo "âœ… Platform Admin role created: $ROLE_ARN"
          echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT

          # Wait for role propagation
          sleep 10

  # ===========================================================================
  # STEP 2: Setup Customer Account (Account 3)
  # ===========================================================================
  setup-customer-account:
    name: "ðŸ—ï¸ Setup Customer Account (Account 3)"
    runs-on: ubuntu-latest
    needs: [validate, setup-platform-admin]

    outputs:
      customer_account_role_arn: ${{ steps.create-role.outputs.role_arn }}

    steps:
      - name: Configure AWS (Customer Account - static keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_CUSTOMER }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_CUSTOMER }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Validate identity
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          if [ "$ACCOUNT_ID" != "${{ inputs.customer_account_id }}" ]; then
            echo "::error::Expected Account ${{ inputs.customer_account_id }} but got $ACCOUNT_ID"
            exit 1
          fi
          echo "âœ… Authenticated to Customer Account: $ACCOUNT_ID"

      - name: Create Customer Account IAM Role
        id: create-role
        env:
          PLATFORM_ADMIN_ACCOUNT_ID: ${{ inputs.platform_admin_account_id }}
          PLATFORM_ADMIN_ROLE_ARN: ${{ needs.setup-platform-admin.outputs.platform_admin_role_arn }}
        run: |
          set -euo pipefail
          ROLE_NAME="${{ env.PROJECT }}-gh-customer-account"

          EXTERNAL_ID="${{ secrets.CROSS_ACCOUNT_EXTERNAL_ID }}"
          if [ -z "$EXTERNAL_ID" ]; then
            EXTERNAL_ID="${{ env.PROJECT }}-xaccount-$(date +%Y)"
            echo "âš ï¸ CROSS_ACCOUNT_EXTERNAL_ID secret not set, using fallback: $EXTERNAL_ID"
          fi

          # Trust policy: allow Platform Admin role to assume this role (with TagSession)
          printf '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"AWS":"%s"},"Action":["sts:AssumeRole","sts:TagSession"],"Condition":{"StringEquals":{"sts:ExternalId":"%s"}}}]}' \
            "${PLATFORM_ADMIN_ROLE_ARN}" "${EXTERNAL_ID}" > /tmp/trust-policy.json

          # Check if already exists
          EXISTING_ARN=$(aws iam get-role --role-name "$ROLE_NAME" \
            --query 'Role.Arn' --output text 2>/dev/null || echo "")

          if [ -n "$EXISTING_ARN" ] && [ "$EXISTING_ARN" != "None" ]; then
            echo "âœ… Role already exists: $EXISTING_ARN â€” updating trust policy..."
            aws iam update-assume-role-policy \
              --role-name "$ROLE_NAME" \
              --policy-document file:///tmp/trust-policy.json
            echo "âœ… Trust policy updated with sts:TagSession"
            ROLE_ARN="$EXISTING_ARN"
            # Fall through to update permissions policy below
          else

            ROLE_ARN=$(aws iam create-role \
              --role-name "$ROLE_NAME" \
              --assume-role-policy-document file:///tmp/trust-policy.json \
              --description "Cross-account role for ${{ env.PROJECT }} customer account" \
              --tags Key=Project,Value="${{ env.PROJECT }}" Key=ManagedBy,Value=github-actions \
              --query 'Role.Arn' --output text)
            echo "âœ… Customer Account role created: $ROLE_ARN"
          fi

          # Customer Account permissions: DynamoDB + IAM + S3 state access + CloudFormation
          # Always applied to ensure policy stays up-to-date
          printf '%s\n' '{' \
            '"Version": "2012-10-17",' \
            '"Statement": [' \
            '  {' \
            '    "Sid": "DynamoDB",' \
            '    "Effect": "Allow",' \
            '    "Action": "dynamodb:*",' \
            '    "Resource": "*"' \
            '  },' \
            '  {' \
            '    "Sid": "IAMLimited",' \
            '    "Effect": "Allow",' \
            '    "Action": [' \
            '      "iam:PassRole",' \
            '      "iam:GetRole",' \
            '      "iam:CreateRole",' \
            '      "iam:DeleteRole",' \
            '      "iam:AttachRolePolicy",' \
            '      "iam:DetachRolePolicy",' \
            '      "iam:PutRolePolicy",' \
            '      "iam:DeleteRolePolicy",' \
            '      "iam:GetRolePolicy",' \
            '      "iam:ListRolePolicies",' \
            '      "iam:ListAttachedRolePolicies",' \
            '      "iam:ListInstanceProfilesForRole",' \
            '      "iam:TagRole",' \
            '      "iam:UntagRole",' \
            '      "iam:UpdateAssumeRolePolicy"' \
            '    ],' \
            '    "Resource": "*"' \
            '  },' \
            '  {' \
            '    "Sid": "STS",' \
            '    "Effect": "Allow",' \
            '    "Action": "sts:GetCallerIdentity",' \
            '    "Resource": "*"' \
            '  },' \
            '  {' \
            '    "Sid": "TerraformState",' \
            '    "Effect": "Allow",' \
            '    "Action": [' \
            '      "s3:GetObject",' \
            '      "s3:PutObject",' \
            '      "s3:DeleteObject",' \
            '      "s3:ListBucket"' \
            '    ],' \
            '    "Resource": [' \
            "      \"arn:aws:s3:::${PROJECT}-terraform-state\"," \
            "      \"arn:aws:s3:::${PROJECT}-terraform-state/*\"" \
            '    ]' \
            '  },' \
            '  {' \
            '    "Sid": "TerraformLock",' \
            '    "Effect": "Allow",' \
            '    "Action": [' \
            '      "dynamodb:GetItem",' \
            '      "dynamodb:PutItem",' \
            '      "dynamodb:DeleteItem"' \
            '    ],' \
            '    "Resource": "arn:aws:dynamodb:*:*:table/'"${PROJECT}"'-terraform-locks"' \
            '  },' \
            '  {' \
            '    "Sid": "CloudFormation",' \
            '    "Effect": "Allow",' \
            '    "Action": "cloudformation:*",' \
            '    "Resource": "*"' \
            '  },' \
            '  {' \
            '    "Sid": "SSMRead",' \
            '    "Effect": "Allow",' \
            '    "Action": [' \
            '      "ssm:GetParameter",' \
            '      "ssm:GetParameters",' \
            '      "ssm:GetParametersByPath",' \
            '      "ssm:DescribeParameters",' \
            '      "ssm:PutParameter",' \
            '      "ssm:DeleteParameter",' \
            '      "ssm:AddTagsToResource",' \
            '      "ssm:RemoveTagsFromResource",' \
            '      "ssm:ListTagsForResource"' \
            '    ],' \
            '    "Resource": "*"' \
            '  }' \
            ']' \
            '}' > /tmp/customer-account-policy.json

          aws iam put-role-policy \
            --role-name "$ROLE_NAME" \
            --policy-name "${ROLE_NAME}-policy" \
            --policy-document file:///tmp/customer-account-policy.json

          echo "âœ… Customer Account permissions policy updated"
          echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT

  # ===========================================================================
  # STEP 3: Set GitHub Variables + Output Instructions
  # ===========================================================================
  configure-github:
    name: "âš™ï¸ Configure GitHub & Summary"
    runs-on: ubuntu-latest
    needs: [validate, setup-platform-admin, setup-customer-account]

    steps:
      # â”€â”€ Apply cross-account S3 bucket policy (customer role now exists) â”€â”€
      - name: Configure AWS (Platform Admin Account)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PLATFORM_ADMIN }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PLATFORM_ADMIN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Apply cross-account bucket policy
        env:
          BUCKET: ${{ needs.setup-platform-admin.outputs.tf_state_bucket }}
          CUSTOMER_ROLE_ARN: ${{ needs.setup-customer-account.outputs.customer_account_role_arn }}
        run: |
          set -euo pipefail
          printf '{"Version":"2012-10-17","Statement":[{"Sid":"AllowCustomerAccountTFState","Effect":"Allow","Principal":{"AWS":"%s"},"Action":["s3:GetObject","s3:PutObject","s3:DeleteObject"],"Resource":"arn:aws:s3:::%s/*"},{"Sid":"AllowCustomerAccountListBucket","Effect":"Allow","Principal":{"AWS":"%s"},"Action":"s3:ListBucket","Resource":"arn:aws:s3:::%s"}]}' \
            "${CUSTOMER_ROLE_ARN}" "${BUCKET}" "${CUSTOMER_ROLE_ARN}" "${BUCKET}" > /tmp/bucket-policy.json

          # Retry loop: IAM role propagation can take up to 30s
          for attempt in 1 2 3 4 5 6; do
            echo "Attempt $attempt: Applying bucket policy..."
            if aws s3api put-bucket-policy --bucket "$BUCKET" --policy file:///tmp/bucket-policy.json 2>/dev/null; then
              echo "âœ… Cross-account bucket policy applied"
              exit 0
            fi
            echo "â³ IAM role not yet propagated, waiting 10s..."
            sleep 10
          done
          echo "::error::Failed to apply bucket policy after 6 attempts â€” IAM role may not have propagated"
          exit 1

      # â”€â”€ Auto-set GitHub secrets if GH_PAT is available â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Auto-set GitHub environment secrets
        if: inputs.auto_set_secrets == true
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
          PLATFORM_ADMIN_ROLE: ${{ needs.setup-platform-admin.outputs.platform_admin_role_arn }}
          CUSTOMER_ACCOUNT_ROLE: ${{ needs.setup-customer-account.outputs.customer_account_role_arn }}
          TF_BUCKET: ${{ needs.setup-platform-admin.outputs.tf_state_bucket }}
          TF_TABLE: ${{ needs.setup-platform-admin.outputs.tf_lock_table }}
        run: |
          set -euo pipefail
          EXTERNAL_ID="${{ env.PROJECT }}-xaccount-$(date +%Y)"

          if [ -z "${GH_TOKEN}" ]; then
            echo "::warning::GH_PAT secret not set â€” skipping automatic secret configuration. Set secrets manually (see summary below)."
            exit 0
          fi

          ENV="dev"
          REPO="${{ github.repository }}"

          echo "ðŸ”§ Setting repository variables..."
          gh variable set PROJECT_NAME --repo "$REPO" --body "${{ inputs.project_name }}" || echo "::warning::Failed to set PROJECT_NAME variable"
          gh variable set AWS_REGION   --repo "$REPO" --body "${{ inputs.aws_region }}" || echo "::warning::Failed to set AWS_REGION variable"

          echo "ðŸ”§ Setting environment secrets for '$ENV'..."
          gh secret set PLATFORM_ADMIN_ROLE_ARN    --repo "$REPO" --env "$ENV" --body "${PLATFORM_ADMIN_ROLE}"
          gh secret set CUSTOMER_ACCOUNT_ROLE_ARN  --repo "$REPO" --env "$ENV" --body "${CUSTOMER_ACCOUNT_ROLE}"
          gh secret set TF_STATE_BUCKET            --repo "$REPO" --env "$ENV" --body "${TF_BUCKET}"
          gh secret set TF_LOCK_TABLE              --repo "$REPO" --env "$ENV" --body "${TF_TABLE}"
          gh secret set PLATFORM_ADMIN_ACCOUNT_ID  --repo "$REPO" --env "$ENV" --body "${{ inputs.platform_admin_account_id }}"
          gh secret set CROSS_ACCOUNT_EXTERNAL_ID  --repo "$REPO" --env "$ENV" --body "${EXTERNAL_ID}"

          echo "âœ… All environment secrets set automatically for '$ENV'"
          echo "### âœ… GitHub Secrets Auto-Configured" >> $GITHUB_STEP_SUMMARY
          echo "All environment secrets for \`$ENV\` have been set automatically." >> $GITHUB_STEP_SUMMARY

      # â”€â”€ Optionally delete static AWS keys â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Delete static AWS keys
        if: inputs.delete_static_keys == true
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          set -euo pipefail

          if [ -z "${GH_TOKEN}" ]; then
            echo "::warning::GH_PAT secret not set â€” cannot delete static keys automatically. Delete them manually."
            exit 0
          fi

          REPO="${{ github.repository }}"
          echo "ðŸ—‘ï¸ Deleting static AWS keys from GitHub secrets..."

          gh secret delete AWS_ACCESS_KEY_ID_PLATFORM_ADMIN     --repo "$REPO" 2>/dev/null && echo "âœ… Deleted AWS_ACCESS_KEY_ID_PLATFORM_ADMIN" || echo "âš ï¸ AWS_ACCESS_KEY_ID_PLATFORM_ADMIN not found (already deleted?)"
          gh secret delete AWS_SECRET_ACCESS_KEY_PLATFORM_ADMIN --repo "$REPO" 2>/dev/null && echo "âœ… Deleted AWS_SECRET_ACCESS_KEY_PLATFORM_ADMIN" || echo "âš ï¸ AWS_SECRET_ACCESS_KEY_PLATFORM_ADMIN not found (already deleted?)"
          gh secret delete AWS_ACCESS_KEY_ID_CUSTOMER            --repo "$REPO" 2>/dev/null && echo "âœ… Deleted AWS_ACCESS_KEY_ID_CUSTOMER" || echo "âš ï¸ AWS_ACCESS_KEY_ID_CUSTOMER not found (already deleted?)"
          gh secret delete AWS_SECRET_ACCESS_KEY_CUSTOMER        --repo "$REPO" 2>/dev/null && echo "âœ… Deleted AWS_SECRET_ACCESS_KEY_CUSTOMER" || echo "âš ï¸ AWS_SECRET_ACCESS_KEY_CUSTOMER not found (already deleted?)"

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ—‘ï¸ Static AWS Keys Deleted" >> $GITHUB_STEP_SUMMARY
          echo "All 4 static AWS access key secrets have been removed. OIDC is now the only auth method." >> $GITHUB_STEP_SUMMARY

      - name: Final summary with copy-paste commands
        env:
          PLATFORM_ADMIN_ROLE: ${{ needs.setup-platform-admin.outputs.platform_admin_role_arn }}
          CUSTOMER_ACCOUNT_ROLE: ${{ needs.setup-customer-account.outputs.customer_account_role_arn }}
          TF_BUCKET: ${{ needs.setup-platform-admin.outputs.tf_state_bucket }}
          TF_TABLE: ${{ needs.setup-platform-admin.outputs.tf_lock_table }}
        run: |
          EXTERNAL_ID="${{ env.PROJECT }}-xaccount-$(date +%Y)"
          {
            echo "## âœ… Prerequisites Created Successfully!"
            echo ""
            echo "### Resources Created"
            echo ""
            echo "| Resource | Account | Value |"
            echo "|----------|---------|-------|"
            echo "| OIDC Provider | Platform Admin (Account 2) | \`token.actions.githubusercontent.com\` |"
            echo "| Platform Admin Role | Account 2 | \`${PLATFORM_ADMIN_ROLE}\` |"
            echo "| Customer Account Role | Account 3 | \`${CUSTOMER_ACCOUNT_ROLE}\` |"
            echo "| TF State Bucket | Account 2 | \`${TF_BUCKET}\` |"
            echo "| TF Lock Table | Account 2 | \`${TF_TABLE}\` |"
            echo ""
            echo "---"
            echo ""
            echo "### ðŸ”§ Manual commands (if auto_set_secrets was disabled or GH_PAT is missing)"
            echo ""
            echo '```bash'
            echo "# Step 1: Set repository variables (run once)"
            echo "gh variable set PROJECT_NAME --body \"${{ inputs.project_name }}\""
            echo "gh variable set AWS_REGION   --body \"${{ inputs.aws_region }}\""
            echo ""
            echo "# Step 2: Set environment secrets (repeat for staging/prod)"
            echo "ENV=dev"
            echo ""
            echo "gh secret set PLATFORM_ADMIN_ROLE_ARN    --env \$ENV --body \"${PLATFORM_ADMIN_ROLE}\""
            echo "gh secret set CUSTOMER_ACCOUNT_ROLE_ARN  --env \$ENV --body \"${CUSTOMER_ACCOUNT_ROLE}\""
            echo "gh secret set TF_STATE_BUCKET            --env \$ENV --body \"${TF_BUCKET}\""
            echo "gh secret set TF_LOCK_TABLE              --env \$ENV --body \"${TF_TABLE}\""
            echo "gh secret set PLATFORM_ADMIN_ACCOUNT_ID  --env \$ENV --body \"${{ inputs.platform_admin_account_id }}\""
            echo "gh secret set CROSS_ACCOUNT_EXTERNAL_ID  --env \$ENV --body \"${EXTERNAL_ID}\""
            echo "gh secret set BOOTSTRAP_ADMIN_PASSWORD   --env \$ENV --body \"YourStrongPassword@2025\""
            echo ""
            echo "# Step 3: Delete the static keys (no longer needed!)"
            echo "gh secret delete AWS_ACCESS_KEY_ID_PLATFORM_ADMIN"
            echo "gh secret delete AWS_SECRET_ACCESS_KEY_PLATFORM_ADMIN"
            echo "gh secret delete AWS_ACCESS_KEY_ID_CUSTOMER"
            echo "gh secret delete AWS_SECRET_ACCESS_KEY_CUSTOMER"
            echo '```'
            echo ""
            echo "### ðŸš€ Then run Bootstrap workflows:"
            echo '```bash'
            echo "gh workflow run \"01 Â· Bootstrap Platform Admin\" -f environment=dev"
            echo "# Wait for completion, then:"
            echo "gh workflow run \"02 Â· Bootstrap Customer Account\" -f environment=dev"
            echo '```'
            echo ""
            echo "### After Bootstrap, set Terraform output secrets:"
            echo '```bash'
            echo "cd infra/control-plane/terraform"
            echo "gh secret set VITE_API_BASE_URL         --env dev --body \"\$(terraform output -raw api_gateway_url)\""
            echo "gh secret set VITE_COGNITO_USER_POOL_ID --env dev --body \"\$(terraform output -raw cognito_user_pool_id)\""
            echo "gh secret set VITE_COGNITO_CLIENT_ID    --env dev --body \"\$(terraform output -raw cognito_client_id)\""
            echo "gh secret set VITE_COGNITO_DOMAIN       --env dev --body \"\$(terraform output -raw cognito_domain)\""
            echo "gh secret set COGNITO_USER_POOL_ID      --env dev --body \"\$(terraform output -raw cognito_user_pool_id)\""
            echo "gh secret set DYNAMODB_TABLE_NAME       --env dev --body \"\$(terraform output -raw control_plane_dynamodb_table)\""
            echo '```'
            echo ""
            echo "---"
            echo ""
            echo "> âš ï¸ **Delete your static AWS keys** from GitHub secrets after setting the environment secrets above."
            echo "> All future workflows use OIDC â€” no static keys needed."
          } >> $GITHUB_STEP_SUMMARY
